{"meta":{"title":"yinqm_Blog","subtitle":"书不成字，纸短情长","description":"小破站还没设计好，先将就着，哈哈哈哈","author":"Eric Yin","url":"http://yinqm.com","root":"/"},"pages":[{"title":"","date":"2020-03-21T05:54:48.989Z","updated":"2020-03-21T05:54:48.989Z","comments":false,"path":"categories/index.html","permalink":"http://yinqm.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-21T05:54:31.623Z","updated":"2020-03-21T05:54:31.623Z","comments":false,"path":"tags/index.html","permalink":"http://yinqm.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"新文档","slug":"新文档","date":"2020-06-30T15:45:52.875Z","updated":"2020-06-30T15:45:53.475Z","comments":true,"path":"2020/06/30/新文档/","link":"","permalink":"http://yinqm.com/2020/06/30/%E6%96%B0%E6%96%87%E6%A1%A3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"MachineLearning07","slug":"MachineLearning07","date":"2020-03-28T08:24:04.000Z","updated":"2020-03-28T08:51:21.429Z","comments":true,"path":"2020/03/28/MachineLearning07/","link":"","permalink":"http://yinqm.com/2020/03/28/MachineLearning07/","excerpt":"","text":"【核方法】核 核的介绍&emsp;&emsp;内核方法是一类用于模式分析或识别的算法，其最知名的使用是在支持向量机（SVM）。模式分析的一般任务是在一般类型的数据（例如序列，文本文档，点集，向量，图像等）中找到并研究一般类型的关系（例如聚类，排名，主成分，相关性，分类）图表等）。内核方法将数据映射到更高维的空间，希望在这个更高维的空间中，数据可以变得更容易分离或更好的结构化。对这种映射的形式也没有约束，这甚至可能导致无限维空间。然而，这种映射函数几乎不需要计算的，所以可以说成是在低维空间计算高维空间内积的一个工具。 核的诀窍&emsp;&emsp;内核技巧是一个非常有趣和强大的工具。 它是强大的，因为它提供了一个从线性到非线性的连接以及任何可以只表示两个向量之间的点积的算法。 它来自如下事实：如果我们首先将我们的输入数据映射到更高维的空间，那么我在这个高维的空间进行操作出的效果，在原来那个空间就表现为非线性。 内核技巧非常有趣，因为不需要计算映射。 如果我们的算法只能根据两个向量之间的内积表示，我们所需要的就是用一些其他合适的空间替换这个内积。 这就是”技巧”的地方：无论使用怎样的点积，它都被内核函数替代。 核函数表示特征空间中的内积，如P1所示Xi转置*Xj。使用内核函数，该算法然后可以被携带到更高维空间中，而不将输入点显式映射到该空间中。 这是非常可取的，因为有时我们的高维特征空间甚至可以是无限维，因此不可能计算。在低维中计算高维数据的点积。 核函数的性质 &emsp;&emsp;核函数必须是连续的，对称的，并且最优选地应该具有正（半）定Gram矩阵。据说满足Mercer定理的核是正半定数，意味着它们的核矩阵只有非负特征值。使用肯定的内核确保优化问题将是凸的和解决方案将是唯一的。然而，许多并非严格定义的核函数在实践中表现得很好。一个例子是Sigmoid内核，尽管它广泛使用，但它对于其参数的某些值不是正半定的。 Boughorbel（2005）也实验证明，只有条件正定的内核在某些应用中可能胜过大多数经典内核。 内核还可以分为各向异性静止，各向同性静止，紧凑支撑，局部静止，非稳定或可分离非平稳。此外，内核也可以标记为scale-invariant（规模不变）或scale-dependent（规模依赖），这是一个有趣的属性，因为尺度不变内核驱动训练过程不变的数据的缩放。 核方法 核方法kernel methods (KMs)是一类模式识别的算法。其目的是找出并学习一组数据中的相互的关系。用途较广的核方法有支持向量机、高斯过程等。核方法是解决非线性模式分析问题的一种有效途径，其核心思想是：首先，通过某种非线性映射将原始数据嵌入到合适的高维特征空间；然后，利用通用的线性学习器在这个新的空间中分析和处理模式。 相对于使用通用非线性学习器直接在原始数据上进行分析的范式，核方法有明显的优势： 1.首先，通用非线性学习器不便反应具体应用问题的特性，而核方法的非线性映射由于面向具体应用问题设计而便于集成问题相关的先验知识。2.再者，线性学习器相对于非线性学习器有更好的过拟合控制从而可以更好地保证泛化性能。还有，很重要的一点是核方法还是实现高效计算的途径，它能利用核函数将非线性映射隐含在线性学习器中进行同步计算，使得计算复杂度与高维特征空间的维数无关。 本文对核方法（kernel method）进行简要的介绍:&emsp;&emsp;核方法的主要思想是基于这样一个假设：“在低维空间中不能线性分割的点集，通过转化为高维空间中的点集时，很有可能变为线性可分的” ，例如有两类数据，一类为xb；另一部分为a&lt;x&lt;b。要想在一维空间上线性分开是不可能的。然而我们可以通过F(x)=(x-a)(x-b)把一维空间上的点转化到二维空间上，这样就可以划分两类数据F(x)&gt;0，F(x)&lt;0；从而实现线性分割。然而，如果直接把低维度的数据转化到高维度的空间中，然后再去寻找线性分割平面，会遇到两个大问题，一是由于是在高维度空间中计算，导致维度祸根（curse of dimension）问题；二是非常的麻烦，每一个点都必须先转换到高维度空间，然后求取分割平面的参数等等；怎么解决这些问题？答案是通过核戏法（kernel trick）。（pku, shinningmonster, sewm)Kernel Trick:定义一个核函数.核函数的表达方式一般都不会显式地写为内积的形式，即我们不关心高维度空间的形式。核函数巧妙地解决了上述的问题，在高维度中向量的内积通过低维度的点的核函数就可以计算了。这种技巧被称为Kernel trick。 这里还有一个问题：“为什么我们要关心向量的内积？”，一般地，我们可以把分类（或者回归）的问题分为两类：参数学习的形式和基于实例的学习形式。参数学习的形式就是通过一堆训练数据，把相应模型的参数给学习出来，然后训练数据就没有用了，对于新的数据，用学习出来的参数即可以得到相应的结论；而基于实例的学习（又叫基于内存的学习）则是在预测的时候也会使用训练数据，如KNN算法。而基于实例的学习一般就需要判定两个点之间的相似程度，一般就通过向量的内积来表达。从这里可以看出，核方法不是万能的，它一般只针对基于实例的学习。 紧接着，我们还需要解决一个问题，即核函数的存在性判断和如何构造？ 既然我们不关心高维度空间的表达形式，那么怎么才能判断一个函数是否是核函数呢？Mercer 定理：任何半正定的函数都可以作为核函数。所谓半正定的函数f(xi,xj)，是指拥有训练数据集合（x1,x2,…xn)，我们定义一个矩阵的元素aij = f(xi,xj)，这个矩阵式n*n的，如果这个矩阵是半正定的，那么f(xi,xj)就称为半正定的函数。这个mercer定理不是核函数必要条件，只是一个充分条件，即还有不满足mercer定理的函数也可以是核函数。几种常用的核 常见的核函数有高斯核，多项式核等等，在这些常见核的基础上，通过核函数的性质（如对称性等）可以进一步构造出新的核函数。SVM是核方法应用的经典模型。线性核 线性内核是最简单的内核函数。 它由内积&lt;x，y&gt;加上可选的常数c给出。 使用线性内核的内核算法通常等于它们的非内核对应物，即具有线性内核的KPCA与标准PCA相同。多项式核函数 多项式核是非固定内核。 多项式内核非常适合于所有训练数据都归一化的问题。 表达式：k（x，y）=（αx ^ T y + c）^ d。可调参数是斜率α，常数项c和多项式度d。高斯核 高斯核是径向基函数核的一个例子。或者，它也可以使用来实现。可调参数sigma在内核的性能中起着主要作用，并且应该仔细地调整到手头的问题。 如果过高估计，指数将几乎呈线性，高维投影将开始失去其非线性功率。 另一方面，如果低估，该函数将缺乏正则化，并且决策边界将对训练数据中的噪声高度敏感。指数的内核指数核与高斯核密切相关，只有正态的平方被忽略。 它也是一个径向基函数内核。和高斯核确实很像，拉普拉斯算子核 拉普拉斯核心完全等同于指数内核，除了对sigma参数的变化不那么敏感。 作为等价的，它也是一个径向基函数内核。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yinqm.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数学理论","slug":"数学理论","permalink":"http://yinqm.com/tags/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/"}]},{"title":"MachineLearning06","slug":"MachineLearning06","date":"2020-03-28T08:20:42.000Z","updated":"2020-03-28T08:54:05.077Z","comments":true,"path":"2020/03/28/MachineLearning06/","link":"","permalink":"http://yinqm.com/2020/03/28/MachineLearning06/","excerpt":"","text":"【支持向量机SVM】","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yinqm.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数学理论","slug":"数学理论","permalink":"http://yinqm.com/tags/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/"}]},{"title":"MachineLearning05","slug":"MachineLearning05","date":"2020-03-27T14:53:24.000Z","updated":"2020-03-27T17:00:43.286Z","comments":true,"path":"2020/03/27/MachineLearning05/","link":"","permalink":"http://yinqm.com/2020/03/27/MachineLearning05/","excerpt":"","text":"【降维】P1-&gt;降维?why;降维的分类;几何角度分析数据稀疏性; 降维方法 降维方法分为线性和非线性降维，非线性降维又分为基于核函数和基于特征值的方法。1、线性降维方法：PCA 、ICA LDA、LFA、LPP(LE的线性表示)2、非线性降维方法：（1）基于核函数的非线性降维方法：KPCA 、KICA、KDA（2）基于特征值的非线性降维方法（流型学习）：ISOMAP、LLE、LE、LPP、LTSA、MVU 降维概念：通过单幅图像数据的高维化，将单幅图像转化为高维空间中的数据集合，对其进行非线性降维。寻求其高维数据流形本征结构的一维表示向量，将其作为图像数据的特征表达向量。 目的：若原特征空间是D维的,现希望降至D-1维的，用来进行特征选择和特征提取。①特征选择：选择重要的特征子集，删除其余特征；②特征提取：由原始特征形成的较少的新特征。在特征提取中，我们要找到k个新的维度的集合，这些维度是原来k个维度的组合，这个方法可以是监督的，也可以是非监督的，如PCA是非监督的，LDA是监督的。 作用：（1）降低时间的复杂度和空间复杂度（2）节省了提取不必要特征的开销（3）去掉数据集中夹杂的噪音（4）较简单的模型在小数据集上有更强的鲁棒性（5）当数据能有较少的特征进行解释，我们可以更好地解释数据，是的我们可以提取知识（6）实现数据的可视化 运用：通过单幅图像数据的高维化,将单幅图像转化为高维空间中的数据集合,对其进行非线性降维,寻求其高维数据流形本征结构的一维表示向量,将其作为图像数据的特征表达向量。从而将高维图像识别问题转化为特征表达向量的识别问题,大大降低了计算的复杂程度,减少了冗余信息所造成的识别误差,提高了识别的精度。通过指纹图像的实例说明,将非线性降维方法(如Laplacian Eigenmap方法)应用于图像数据识别问题,在实际中是可行的,在计算上是简单的,可大大改善常用方法(如K-近邻方法)的效能,获得更好的识别效果。此外,该方法对于图像数据是否配准是不敏感的,可对不同大小的图像进行识别,这大大简化了识别的过程。 子集选择:对于n个属性，有2n个可能的子集。穷举搜索找出属性的最佳子集可能是不现实的，特别是当n和数据类的数目增加时。通常使用压缩搜索空间的启发式算法，通常这些方法是典型的贪心算法，在搜索属性空间时，总是做看上去是最佳的选择。他们的策略是局部最优选择，期望由此导致全局最优解。在实践中，这种贪心方法是有效的，并可以逼近最优解。子集选择的缺点： 案例：假设对一张100*100像素的图片做人脸识别，每个像素是一个特征，那么会有10000个特征，而对应的类别标签y仅仅是0/1值，1代表是人脸。这么多特征不仅训练复杂，而且不必要特征对结果会带来不可预知的影响，但我们想得到降维后的一些最佳特征（与y关系最密切的）。 主要思想：将一个高维空间中的数据投影到一个较低维的空间中，且投影后要保证各个类别的类内方差小而类间均值差别大，这意味着同一类的高维数据投影到低维空间后相同类别的聚在一起，而不同类别之间相距较远。 假设有一个D维的边长a=1的超正方体，里面有一个D维的半径为0.5的超球体。则 V超正方体=1 V超球体=K0.5^D当D—&gt;+∞时， 出现一个惊人的发现，当D的值足够大，发现中间的超球体的竟然趋近于零。 &emsp;&emsp;这样扩展到数据来说，随着数据维度的增大，数据的量也会相对稀疏的多。这就是维度灾难。实际上在许多领域的研究与应用中，为了反映事物的多个变量对结果的影响，需要进行大量数据收集以便进行分析寻找规律。多变量、大样本虽然会为研究和应用提供了丰富的信息，但也遇到了以下问题：1.一定程度上增加了数据采集的工作量2.更重要的是在多数情况下，许多变量之间可能存在相关性，从而增加了问题分析的复杂性，同时对分析带来不便。3.如果分别对每个指标进行分析，分析往往是孤立的，而不是综合的。盲目减少指标会损失很多信息，容易产生错误的结论。&emsp;&emsp;因此需要找到一个合理的方法，在减少需要分析的指标同时，尽量减少原指标包含信息的损失，以达到对所收集数据进行全面分析的目的 ，由于各变量间存在一定的相关关系，因此有可能用较少的综合指标分别综合存在于各变量中的各类信息。主成分分析就属于这类降维的方法。 P2-&gt;预备知识; 数据data特征矩阵表示；样本均值(Sample Mean)；​样本协方差(Sample Covariance)；H为中心矩阵(centering matrix)，中心矩阵将X每一维都减去均值，实现归一化。p3-&gt;经典PCA 一个中心：原始特征空间的重构，线性相关特征–&gt;线性无关特征（主成分）， 两个基本点： 最大投影方差 ：样本点投影到某方向上分布尽量分散（投影方差最大），该方向就是主成分。 最小重构距离：样本点投影后重构回去所花的代价要最小，投影分布越分散（投影方差最大），则重构所需的代价越小。所以，这两个方法其实是等价的。 最大投影方差：找到一个方向，使得数据在这些投影方向上的方差最大。计算原始数据在这些正交基上投影的方差，方差越大，就说明在对应正交基上包含了更多的信息量。这个方向就是主成分。 方法：（把n维的降维成k维） 1.去掉均值2.计算协方差矩阵的特征值和特征向量；特征值代表重要程度。3.保留最大的k个特征值对应的特征向量4.把数据转化到上述特征向量构建的新空间 1234567891011121314def pca(dataMat, topNfeat&#x3D;999999): meanVals &#x3D; mean(dataMat) meanRemoved &#x3D; dataMat - meanVals #去均值 covMat &#x3D; cov(meanRemoved, rowvar&#x3D;0) #协方差矩阵 eigVals,eigVects &#x3D; linalg.eig(mat(covMat)) # numpy内建函数，一次性求出特征值和特征向量 eigValInd &#x3D; argsort(eigVals) eigValInd &#x3D; eigValInd[:-(topNfeat+1):-1] redEigVects &#x3D; eigVects[:,eigValInd] # 对特征值从小到大排序 lowDDataMat &#x3D; meanRemoved * redEigVects # 将数据集投影到新的空间，结果是一个低维数据 reconMat &#x3D; (lowDDataMat * redEigVects.T) + meanVals return lowDDataMat, reconMat P4-&gt;最小重构距离角度 最大投影方差基本点如P4，将样本投影到u1和u2上的距离D1&gt;D2，则u1这个特征相对于u2来说就是主成分。最大投影方向就是主成分。首先要对数据进行中心化处理，为什么要进行中心化处理呢？因为主成分变换对正交向量的尺度敏感。数据在变换前需要进行归一化处理。 然后计算投影方差，接着可以将上一步的待求内容转化为最优化问题吹，最后通过拉格朗日函数，将约束项放到最优化问题中，通过极大似然求得最优解。 最小重构距离：在P4中，如果把样本点投影到u1和u2后，再将样本点还原原来的数据，这样的代价，显然u1比u2小的多。（因为u1相对稀疏比较好还原，u2甚至有些点都已经重合了，不容易还原） 有了上面最小重构代价的思想，接下来直接可以给出运算过程，如P4所示。 P5-&gt;SVD角度 去主成分的方法实现是太麻烦了，有没有更简单的方法呢？答案是肯定的，那就是奇异值分解SVD！ 首先得知道特征值和特征向量。Sx=λx,其中S是一个n×n的实对称矩阵，x是一个n维向量，则我们说λ是矩阵S的一个特征值，而x是矩阵S的特征值λ所对应的特征向量。求出特征值和特征向量有什么好处呢？ 就是我们可以将矩阵A特征分解。如果我们求出了矩阵A的n个特征值λ1≤λ2≤…≤λn,以及这n个特征值所对应的特征向量{w1,w2,…wn}，，如果这n个特征向量线性无关，那么矩阵S就可以特征分解,其中G是这n个特征向量所张成的n×n维矩阵，而Σ为这n个特征值为主对角线的n×n维矩阵。注意到要进行特征分解，矩阵S必须为方阵。那么如果S不是方阵，即行和列不相同时，我们还可以对矩阵进行分解吗？答案是可以，此时就要用到奇异值分解SVD。 SVD也是对矩阵进行分解，但是和特征分解不同，SVD并不要求要分解的矩阵为方阵。假设矩阵S是一个m×n的矩阵，那么定义矩阵S的SVD为Hx,其中U是一个m×m的列正交矩阵；Σ是一个m×n的对角矩阵，除了主对角线上的元素以外全为0，主对角线上的每个元素都称为奇异值；V是一个n×n的正交矩阵。U和V都是酉矩阵，即满足：UTU=I,VTV=I。这样可以求出每个奇异值，进而求出奇异值矩阵Σ。 P6-&gt;主成分分析(PCA) 主成分分析(PCA)将样本投影到某一维上，新的坐标的选择方式：找到第一个坐标，数据集在该坐标的方差最大（方差最大也就是我们在这个数据维度上能更好地区分不同类型的数据），然后找到第二个坐标，该坐标与原来的坐标正交。该过程会一直的重复，直到新坐标的数目和原来的特征个数相同，这时候我们会发现数据的大部分方差都在前面几个坐标上表示，这些新的维度就是我们所说的主成分。（1）PCA的基本思想：寻找数据的主轴方向，由主轴构成一个新的坐标系，这里的维数可以比原维数低，然后数据由原坐标系向新坐标系投影，这个投影的过程就是降维的过程。（2）PCA算法的过程①将原始数据中的每一个样本都用向量表示，把所有样本组合起来构成样本矩阵，通常对样本矩阵进行中心化处理，得到中心化样本矩阵。②求中心化后的样本矩阵的协方差；③求协方差矩阵的特征值和特征向量；④将求出的特征值按从大到小的顺序排列，并将其对应的特征向量按照此顺序组合成一个映射矩阵，根据指定的PCA保留的特征个数取出映射矩阵的前n行或者前n列作为最终的映射矩阵；⑤用映射矩阵对数据进行映射，达到数据降维的目的。（3）PCA实例中的小插曲：TF-IDFTF-IDF：term freuency-inverse document frequency,它是一种用于信息检索与文本挖掘的常用加权技术，是一种统计方法，用以评估一字词对于一个文本集或一个语料库中其中一份文件的重要程度。包括两部分，词频和逆向文件频率。（4）协方差矩阵的对角上是方差，非对角线上是协方差。协方差是衡量两个变量同时变化的变化程度。协方差大于0表示x和y中若一个增，另一个也增；小于0表示一个增一个减。（5）PCA推导—最大方差理论在信号处理中认为信号具有较大的方差，噪音具有较小的方差，信噪比越大越好。PCA遵循投影后的样本点间方差最大原则。 线性分类 线性分类 线性分类 LDA（Linear discriminant analysis)线性判别式分析，也叫fisher线性判别，是模式识别中的经典算法。是一种监督学习的降维技术，它的数据集的每个样本是有类别输出的。思想：投影后类内距离最小，类间距离最大。1、线性判别：将高维的模式样本投影到最佳鉴别矢量空间，以达到抽取分类信息和压缩特征空间维数的效果，投影后保证模式样本在新的子空间有最大的类间距离和最小的类内距离，这是一种有效的特征提取方法，使用这个方法，能使得投影后模式样本的类间散布矩阵最大，且同时类内散布矩阵最小。2、与PCA相比较：（1）共同点：①都属于线性方法；②在降维时都采用矩阵分解的方法；③都假设数据符合高斯分布；（2）不同点：①LDA是有监督的；②不能保证投影到的坐标系是正交的（根据类别的标注，关注分类能力）；③降维直接与类别的个数有关，与数据本身的维度无关（原始数据是n维的，有c个类别，降维后一般是到c-1维）④可以用于降维，还可用于分类；⑤选择分类性能最好的投影方向。 LLE1、属于流形学习的一种，和传统的PCA、LDA相比，不再是关注样本方差的降维方法，而是一种关注降维时保持样本局部的线性特征。LLE是将高维流形分成很多小块，每一小块可以用平面代替，然后再在低维中重新拼合起来，且要求保留各点之间的拓扑关系不变。2、LLE思想：首先假设数据在较小的局部是线性的，即某一个数据能够用它邻域中的几个样本来线性表示，可以通过k-近邻的思想来找到它的近邻点。在降维之后，希望样本点对应的投影尽量保持同样的线性关系。即投影前后线性关系的权重参数不变或者改变很小。3、LLE算法推导：（1）首先确定邻域大小的选择;（2）需要找到某个样本Xi和这k个最近邻之间的线性关系（找线性关系是一个回归问题）;（3）由该样本点的局部重建权值矩阵和其近邻点计算出该样本点的输出值;（4）定义一个误差函数; ISOMAP（等距特征映射）1、以线性流形学习方法MDS为理论基础，将经典MDS方法中的欧式距离替换为 *tSNE *TSNE是由SNE衍生出的一张算法，SNE最早出现在2002年，改变了MDN和ISOMAP中基于距离不变的思想，将高维映射到低维的同时，尽量保证相互之间的分布概率不变，SNE将高维和低维中的样本分布都看作高斯分布，而TSNE将低维中的坐标当作T分布，这样的好处是为了让距离大的簇之间距离拉大，从而解决了拥挤问题。 PCA的Python实现 选用Python内置的iris数据集，通过PCA降维，对数据分类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130from __future__ import print_functionfrom sklearn import datasetsimport matplotlib.pyplot as pltfrom pylab import *plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;]&#x3D;Falseimport numpy as npdef shuffle_data(X, y, seed&#x3D;None): if seed: np.random.seed(seed) idx &#x3D; np.arange(X.shape[0]) np.random.shuffle(idx) return X[idx], y[idx]# 正规化数据集 Xdef normalize(X, axis&#x3D;-1, p&#x3D;2): lp_norm &#x3D; np.atleast_1d(np.linalg.norm(X, p, axis)) lp_norm[lp_norm &#x3D;&#x3D; 0] &#x3D; 1 return X &#x2F; np.expand_dims(lp_norm, axis)# 标准化数据集 Xdef standardize(X): X_std &#x3D; np.zeros(X.shape) mean &#x3D; X.mean(axis&#x3D;0) std &#x3D; X.std(axis&#x3D;0) # 做除法运算排除分母不能等于0的情形 for col in range(np.shape(X)[1]): if std[col]: X_std[:, col] &#x3D; (X_std[:, col] - mean[col]) &#x2F; std[col] return X_std# 划分数据集为训练集和测试集def train_test_split(X, y, test_size&#x3D;0.2, shuffle&#x3D;True, seed&#x3D;None): if shuffle: X, y &#x3D; shuffle_data(X, y, seed) n_train_samples &#x3D; int(X.shape[0] * (1-test_size)) x_train, x_test &#x3D; X[:n_train_samples], X[n_train_samples:] y_train, y_test &#x3D; y[:n_train_samples], y[n_train_samples:] return x_train, x_test, y_train, y_test# 计算矩阵X的协方差矩阵def calculate_covariance_matrix(X, Y&#x3D;np.empty((0,0))): if not Y.any(): Y &#x3D; X n_samples &#x3D; np.shape(X)[0] covariance_matrix &#x3D; (1 &#x2F; (n_samples-1)) * (X - X.mean(axis&#x3D;0)).T.dot(Y - Y.mean(axis&#x3D;0)) return np.array(covariance_matrix, dtype&#x3D;float)# 计算数据集X每列的方差def calculate_variance(X): n_samples &#x3D; np.shape(X)[0] variance &#x3D; (1 &#x2F; n_samples) * np.diag((X - X.mean(axis&#x3D;0)).T.dot(X - X.mean(axis&#x3D;0))) return variance# 计算数据集X每列的标准差def calculate_std_dev(X): std_dev &#x3D; np.sqrt(calculate_variance(X)) return std_dev# 计算相关系数矩阵def calculate_correlation_matrix(X, Y&#x3D;np.empty([0])): # 先计算协方差矩阵 covariance_matrix &#x3D; calculate_covariance_matrix(X, Y) # 计算X, Y的标准差 std_dev_X &#x3D; np.expand_dims(calculate_std_dev(X), 1) std_dev_y &#x3D; np.expand_dims(calculate_std_dev(Y), 1) correlation_matrix &#x3D; np.divide(covariance_matrix, std_dev_X.dot(std_dev_y.T)) return np.array(correlation_matrix, dtype&#x3D;float)class PCA(): &quot;&quot;&quot; 主成份分析算法PCA，非监督学习算法. &quot;&quot;&quot; def __init__(self): self.eigen_values &#x3D; None self.eigen_vectors &#x3D; None self.k &#x3D; 2 def transform(self, X): &quot;&quot;&quot; 将原始数据集X通过PCA进行降维 &quot;&quot;&quot; covariance &#x3D; calculate_covariance_matrix(X) # 求解特征值和特征向量 self.eigen_values, self.eigen_vectors &#x3D; np.linalg.eig(covariance) # 将特征值从大到小进行排序，注意特征向量是按列排的，即self.eigen_vectors第k列是self.eigen_values中第k个特征值对应的特征向量 idx &#x3D; self.eigen_values.argsort()[::-1] eigenvalues &#x3D; self.eigen_values[idx][:self.k] eigenvectors &#x3D; self.eigen_vectors[:, idx][:, :self.k] # 将原始数据集X映射到低维空间 X_transformed &#x3D; X.dot(eigenvectors) return X_transformedif __name__ &#x3D;&#x3D; &quot;__main__&quot;: #使用燕尾花数据集 data &#x3D; datasets.load_iris() X &#x3D; data.data y &#x3D; data.target # 将数据集X映射到低维空间 X_trans &#x3D; PCA().transform(X) x1 &#x3D; X_trans[:, 0] x2 &#x3D; X_trans[:, 1] cmap &#x3D; plt.get_cmap(&#39;viridis&#39;) colors &#x3D; [cmap(i) for i in np.linspace(0, 1, len(np.unique(y)))] class_distr &#x3D; [] # 展示不同类别数据的分布 for i, l in enumerate(np.unique(y)): _x1 &#x3D; x1[y &#x3D;&#x3D; l] _x2 &#x3D; x2[y &#x3D;&#x3D; l] _y &#x3D; y[y &#x3D;&#x3D; l] class_distr.append(plt.scatter(_x1, _x2, color&#x3D;colors[i])) # Add a legend plt.legend(class_distr, y, loc&#x3D;1) # Axis labels plt.xlabel(&#39;主成分1&#39;) plt.ylabel(&#39;主成分2&#39;) plt.show() PCA优缺点并存： 优点： 1.它是无监督学习，完全无参数限制的。在PCA的计算过程中完全不需要人为的设定参数或是根据任何经验模型对计算进行干预，最后的结果只与数据相关，与用户是独立的。 2.用PCA技术可以对数据进行降维，同时对新求出的“主元”向量的重要性进行排序，根据需要取前面最重要的部分，将后面的维数省去，可以达到降维从而简化模型或是对数据进行压缩的效果。同时最大程度的保持了原有数据的信息。 3.各主成分之间正交，可消除原始数据成分间的相互影响。 4.计算方法简单，易于在计算机上实现。 缺点： 1.如果用户对观测对象有一定的先验知识，掌握了数据的一些特征，却无法通过参数化等方法对处理过程进行干预，可能会得不到预期的效果，效率也不高。 2.贡献率小的主成分往往可能含有对样本差异的重要信息。 3.特征值矩阵的正交向量空间是否唯一有待讨论。 4.在非高斯分布的情况下，PCA方法得出的主元可能并不是最优的，此时在寻找主元时不能将方差作为衡量重要性的标准。 总结&emsp;&emsp;首先通过几何概念引出维度爆炸带来的问题，接下来通过PCA数据降维来解决之。在讲PCA内容时主要介绍了：经典主成分分析、最大投影方差、最小重构距离，SVD奇异值分解。最后通过Python实现PCA。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yinqm.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数学理论","slug":"数学理论","permalink":"http://yinqm.com/tags/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/"}]},{"title":"JAVA-Collection&泛型","slug":"JAVA-Collection-泛型","date":"2020-03-23T16:16:19.000Z","updated":"2020-03-23T16:32:40.758Z","comments":true,"path":"2020/03/24/JAVA-Collection-泛型/","link":"","permalink":"http://yinqm.com/2020/03/24/JAVA-Collection-%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"【Collection、泛型】主要内容 Collection集合 迭代器 增强for 泛型 第一章 Collection集合1.1 集合概述在前面基础班我们已经学习过并使用过集合ArrayList ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 1.2 集合框架JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map，今天我们主要学习Collection集合，在day04时讲解Map集合。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 Collection集合体系图 其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 1.3 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add(\"小李广\"); coll.add(\"扫地僧\"); coll.add(\"石破天\"); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println(\"判断 扫地僧 是否在集合中\"+coll.contains(\"扫地僧\")); //boolean remove(E e) 删除在集合中的o元素 System.out.println(\"删除石破天：\"+coll.remove(\"石破天\")); System.out.println(\"操作之后集合中元素:\"+coll); // size() 集合中有几个元素 System.out.println(\"集合中有\"+coll.size()+\"个元素\"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println(\"集合中内容为：\"+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 第二章 Iterator迭代器2.1 Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 下面介绍一下迭代的概念： 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(\"串串星人\"); coll.add(\"吐槽星人\"); coll.add(\"汪星人\"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 2.2 迭代器的实现原理我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程： Collection集合体系图 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2.3 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1：遍历数组123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 练习2:遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add(\"小河神\"); coll.add(\"老河神\"); coll.add(\"神婆\"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 第三章 泛型3.1 泛型概述在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。 泛型的概念 大家观察下面代码： 1234567891011121314public class GenericDemo &#123; public static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add(\"abc\"); coll.add(\"itcast\"); coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = coll.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length()); &#125; &#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。 为什么会发生类型转换异常呢？ 我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。 怎么来解决这个问题呢？ Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 3.2 使用泛型的好处上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？ 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 通过我们如下代码体验一下： 123456789101112131415public class GenericDemo2 &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"abc\"); list.add(\"itcast\"); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; &#125;&#125; tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 3.3 泛型的定义与使用我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125; 举例自定义泛型类 123456789101112public class MyGenericClass&lt;MVP&gt; &#123; //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) &#123; this.mvp = mvp; &#125; public MVP getMVP() &#123; return mvp; &#125;&#125; 使用: 123456789101112131415public class GenericClassDemo &#123; public static void main(String[] args) &#123; // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP(\"大胡子登登\"); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); &#125;&#125; 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125; 使用格式：调用方法时，确定泛型的类型 12345678910public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(\"aaa\"); mm.show(123); mm.show(12.45); &#125;&#125; 含有泛型的接口定义格式： 1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， 12345public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E getE(); &#125; 使用格式： 1、定义类时确定泛型的类型 例如 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125; 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125; 确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(\"aa\"); &#125;&#125; 3.4 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 举个例子大家理解使用即可： 12345678public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型 tips:泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 第四章 集合综合案例4.1 案例介绍按照斗地主的规则，完成洗牌发牌的动作。具体规则： 使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 斗地主案例的需求分析 4.2 案例分析 准备牌： 牌可以设计为一个ArrayList,每个字符串为一张牌。每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。牌由Collections类的shuffle方法进行随机排序。 发牌 将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 看牌 直接打印每个集合。 4.3 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.ArrayList;import java.util.Collections;public class Poker &#123; public static void main(String[] args) &#123; /* * 1: 准备牌操作 */ //1.1 创建牌盒 将来存储牌面的 ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;(); //1.2 创建花色集合 ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;(); //1.3 创建数字集合 ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;(); //1.4 分别给花色 以及 数字集合添加元素 colors.add(\"♥\"); colors.add(\"♦\"); colors.add(\"♠\"); colors.add(\"♣\"); for(int i = 2;i&lt;=10;i++)&#123; numbers.add(i+\"\"); &#125; numbers.add(\"J\"); numbers.add(\"Q\"); numbers.add(\"K\"); numbers.add(\"A\"); //1.5 创造牌 拼接牌操作 // 拿出每一个花色 然后跟每一个数字 进行结合 存储到牌盒中 for (String color : colors) &#123; //color每一个花色 //遍历数字集合 for(String number : numbers)&#123; //结合 String card = color+number; //存储到牌盒中 pokerBox.add(card); &#125; &#125; //1.6大王小王 pokerBox.add(\"小☺\"); pokerBox.add(\"大☠\"); // System.out.println(pokerBox); //洗牌 是不是就是将 牌盒中 牌的索引打乱 // Collections类 工具类 都是 静态方法 // shuffer方法 /* * static void shuffle(List&lt;?&gt; list) * 使用默认随机源对指定列表进行置换。 */ //2:洗牌 Collections.shuffle(pokerBox); //3 发牌 //3.1 创建 三个 玩家集合 创建一个底牌集合 ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;(); //遍历 牌盒 必须知道索引 for(int i = 0;i&lt;pokerBox.size();i++)&#123; //获取 牌面 String card = pokerBox.get(i); //留出三张底牌 存到 底牌集合中 if(i&gt;=51)&#123;//存到底牌集合中 dipai.add(card); &#125; else &#123; //玩家1 %3 ==0 if(i%3==0)&#123; player1.add(card); &#125;else if(i%3==1)&#123;//玩家2 player2.add(card); &#125;else&#123;//玩家3 player3.add(card); &#125; &#125; &#125; //看看 System.out.println(\"令狐冲：\"+player1); System.out.println(\"田伯光：\"+player2); System.out.println(\"绿竹翁：\"+player3); System.out.println(\"底牌：\"+dipai); &#125;&#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yinqm.com/tags/JAVA/"}]},{"title":"JAVA——Object类和常用API","slug":"JAVA——Object类和常用API","date":"2020-03-23T15:54:12.000Z","updated":"2020-03-23T16:22:36.476Z","comments":true,"path":"2020/03/23/JAVA——Object类和常用API/","link":"","permalink":"http://yinqm.com/2020/03/23/JAVA%E2%80%94%E2%80%94Object%E7%B1%BB%E5%92%8C%E5%B8%B8%E7%94%A8API/","excerpt":"","text":"【Object类、常用API】主要内容 Object类 Date类 DateFormat类 Calendar类 System类 StringBuilder类 包装类 第一章 Object类1.1 概述java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 1.2 toString方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 1.3 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。 tips：Object类当中的hashCode等其他方法，今后学习。 1.4 Objects类在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 我们可以查看一下源码，学习一下： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; 第二章 日期时间类2.1 Date类概述java.util.Date类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 2.2 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); &#125; &#125; 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = \"2018年12月11日\"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 2.3 练习请使用日期时间相关的API，计算出一个人已经出生了多少天。 思路： 1.获取当前时间对应的毫秒值 2.获取自己出生日期对应的毫秒值 3.两个时间相减（当前时间– 出生日期） 代码实现： 123456789101112131415161718192021public static void function() throws Exception &#123; System.out.println(\"请输入出生日期 格式 YYYY-MM-dd\"); // 获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); // 将字符串日期,转成Date对象 // 创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); // 调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); // 获取今天的日期对象 Date todayDate = new Date(); // 将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long secone = todaySecond-birthdaySecond; if (secone &lt; 0)&#123; System.out.println(\"还没出生呢\"); &#125; else &#123; System.out.println(secone/1000/60/60/24); &#125;&#125; 2.4 Calendar类概念日历我们都见过 java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 123456789101112131415import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); &#125; &#125; 123456789import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日 &#125;&#125; add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 123456789101112import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; &#125;&#125; getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 第三章 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 3.1 currentTimeMillis方法实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 12345678import java.util.Date;public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; 练习验证for循环打印数字1-9999所需要使用的时间（毫秒） 12345678910public class SystemTest1 &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; long end = System.currentTimeMillis(); System.out.println(\"共耗时毫秒：\" + (end - start)); &#125;&#125; 3.2 arraycopy方法 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 练习将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] 12345678910111213import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; 第四章 StringBuilder类4.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = \"Hello\"; s += \"World\"; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWord 。 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 4.2 StringBuilder概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容(默认16字符空间，超过自动扩充)。 StringBuilder的原理 4.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"itcast\"); System.out.println(sb2); // itcast &#125;&#125; 4.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 12345678910111213141516171819202122public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append(\"hello\"); //对比一下 System.out.println(\"builder:\"+builder); System.out.println(\"builder2:\"+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\"+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 第五章 包装类5.1 概述Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5.2 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—-&gt;包装对象 12Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 1int num = i.intValue(); 5.3自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 5.3 基本类型与字符串之间的转换基本类型转换为String 基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： 1基本类型直接与””相连接即可；如：34+&quot;&quot; String转换成对应的基本类型 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt(\"100\"); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yinqm.com/tags/JAVA/"}]},{"title":"MachineLearning04","slug":"MachineLearning03","date":"2020-03-22T03:11:37.000Z","updated":"2020-03-22T03:43:01.387Z","comments":true,"path":"2020/03/22/MachineLearning03/","link":"","permalink":"http://yinqm.com/2020/03/22/MachineLearning03/","excerpt":"","text":"线性回归P1最小二乘法 &amp; P2概率视角 最小二乘法其实又叫最小平方法，是一种数据拟合的优化技术。实质上是利用最小误差的平方寻求数据的最佳匹配函数，利用最小二乘法可以便捷的求得未知的数据，起到预测的作用，并且是的这些预测的数据与实际数据之间的误差平方和达到最小。一般应用在曲线拟合的目的上。 拟合示意图python代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#%%import matplotlib import matplotlib.pyplot as pltimport numpy as npfrom sklearn import datasets, linear_modelimport pandas as pd # Load CSV and columnsdf = pd.read_csv(\"Housing.csv\") Y = df['price']X = df['lotsize'] X=X.values.reshape(len(X),1)Y=Y.values.reshape(len(Y),1) # Split the data into training/testing setsX_train = X[:-250]X_test = X[-250:] # Split the targets into training/testing setsY_train = Y[:-250]Y_test = Y[-250:] # Create linear regression objectregr = linear_model.LinearRegression() # Train the model using the training setsregr.fit(X_train, Y_train) # Plot outputsplt.scatter(X_test, Y_test, color='black')plt.title('Test Data')plt.xlabel('Size')plt.ylabel('Price')plt.xticks(())plt.yticks(()) # Plot outputsplt.plot(X_test, regr.predict(X_test), color='red',linewidth=3) plt.show()#%%# 画出训练集的拟合曲线，第一种方法predict# Plot outputsplt.scatter(X_train, Y_train, color='black')plt.title('Train Data')plt.xlabel('Size')plt.ylabel('Price')plt.xticks(())plt.yticks(()) # Plot outputsplt.plot(X_train, regr.predict(X_train), color='red',linewidth=3) plt.show() #%%# 画出训练集的拟合曲线，第二种方法coef_*x+intercept_ # Plot outputsplt.scatter(X_train, Y_train, color='black')plt.title('Test Data')plt.xlabel('Size')plt.ylabel('Price')plt.xticks(())plt.yticks(()) # Plot outputsplt.plot(X_train, regr.coef_*X_train+regr.intercept_, color='red',linewidth=3) plt.show() #%%# 查看coef_*x+intercept_的值和regr.predict()的值是否相等，相减为0regr.coef_*X_train+regr.intercept_ - regr.predict(X_train) P3正则化 &amp; 正则化几何解释 正则化看起来有些抽象，其直译”规则化”，本质其实很简单，就是给模型加一些规则限制，约束要优化参数，目的是防止过拟合。其中最常见的规则限制就是添加先验约束，其中L1相当于添加Laplace先验，L相当于添加Gaussian先验。 L1正则是在原始的loss函数上加上一个L1正则化项，这个L1正则项实际就是在loss函数上添加一个结构化风险项，因此正则化其实和“带约束的目标函数”是等价的。而L1正则项就是一个1范数，本质相当于添加一个Laplace先验知识。同理，L2正则化项是一个2范数，本质却相当于添加一个Gaussian先验知识。 过拟合的时候，拟合函数的系数往往非常大，为什么？如P4所示，过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。 一般来说，监督学习可以看做最小化P3的损失函数，第一项L衡量我们的模型（分类或者回归）对第i个样本的预测值f(xi;w)和真实的标签yi之前的误差。因为我们的模型是要拟合我们的训练样本的嘛，所以我们要求这一项最小，也就是要求我们的模型尽量的拟合我们的训练数据。但正如上面说言，我们不仅要保证训练误差最小，我们更希望我们的模型测试误差小，所以我们需要加上第二项，也就是对参数w的规则化函数Ω(w)去约束我们的模型尽量的简单。其中这个规则化函数就是我们常见的L0,L1,L2范数。 正则化的目的：防止过拟合！ 正则化的本质：约束（限制）要优化的参数。 贝叶斯决策理论是主观贝叶斯派归纳理论的重要组成部分。 贝叶斯决策就是在不完全情报下，对部分未知的状态用主观概率估计，然后用贝叶斯公式对发生概率进行修正，最后再利用期望值和修正概率做出最优决策。贝叶斯决策理论方法是统计模型决策中的一个基本方法，其基本思想是： 已知类条件概率密度参数表达式和先验概率 利用贝叶斯公式转换成后验概率 根据后验概率大小进行决策分类 从贝叶斯角度理解正则化从我们平时最为熟悉的最小二乘回归、Ridge回归和LASSO回归入手。从概率论的角度：Least Square的解析解可以用Gaussian分布以及最大似然估计求得Ridge回归可以用Gaussian分布和最大后验估计解释LASSO回归可以用Laplace分布和最大后验估计解释给定观察数据,贝叶斯方法通过最大化后验概率估计参数w。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yinqm.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数学理论","slug":"数学理论","permalink":"http://yinqm.com/tags/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/"}]},{"title":"MachineLearning03","slug":"MachineLearning04","date":"2020-03-21T15:28:25.000Z","updated":"2020-03-21T16:40:32.728Z","comments":true,"path":"2020/03/21/MachineLearning04/","link":"","permalink":"http://yinqm.com/2020/03/21/MachineLearning04/","excerpt":"","text":"线性分类P1线性分类概述 &amp; P2感知机 分类是机器学习中的一个核心问题，在监督学习中，当输出变量Y取有限个离散值时，预测问题便成为分类问题。从数据中学习一个分类模型或分类决策函数，称为分类器。分类器对新的输入进行输出的预测，称为分类，可能的输出称为类，分类的类别为多个时，称为多类分类问题，主要研究的都为二分类问题。许多机器学习方法都是可以用来解分类问题，比如：感知机、朴素贝叶斯、支持向量机、决策树、逻辑回归、AdaBoost、神经网络等等。感知机是神经网络和支持向量机的基础，所以把感知机弄清楚对于其它算法的理解还是挺有必要的。 感知机是一种广泛使用的线性分类器。就是说数据必须是线性可分的(虽然实际中很难达到要求，但是可以通过一些方法将数据集变为线性可分)，属于判别模型(Discriminative Model)。感知器可谓是最简单的人工神经网络，只有一个神经元。感知器是对生物神经元的简单数学模拟，有与生物神经元相对应的部件，如权重（突触）、偏置（阈值）及激活函数（细胞体），输出为+1或-1。感知器是一种简单的两类线性分类模型 线性分类 P3线性判别分析 线性判别分析(linear discriminant analysis，LDA)是对费舍尔的线性鉴别方法的归纳，这种方法使用统计学，模式识别和机器学习方法，试图找到两类物体或事件的特征的一个线性组合，以能够特征化或区分它们。所得的组合可用来作为一个线性分类器，或者，更常见的是，为后续的分类做降维处理。 假设我们对一张100*100像素的图片做人脸识别，每个像素是一个特征，那么会有10000个特征，而对应的类别标签y仅仅是0/1值，1代表是人脸。这么多特征不仅训练复杂，而且不必要特征对结果会带来不可预知的影响，但我们想得到降维后的一些最佳特征（与y关系最密切的）。 主要思想是将一个高维空间中的数据投影到一个较低维的空间中，且投影后要保证各个类别的类内方差小而类间均值差别大，这意味着同一类的高维数据投影到低维空间后相同类别的聚在一起，而不同类别之间相距较远。 线性分类 P4目标函数分析 &amp; P5逻辑回归 线性判别分析（LDA）是一种有监督的数据降维算法，它的目标是最大化类间差异，最小化类内差异。数据经过投影之后，在低维空间里，同类样本聚集在一起，不同类的样本相距尽可能远。类内差异用每个类的方差来衡量，类间差异用各个类的类中心之间的距离来衡量，二者的比值为我们要优化的目标。由此构造出如P4中的损失函数，求解这一问题最后归结为求解矩阵的特征值问题。前面介绍的感知器算法的目标函数，欧氏距离损失，代表的都是经验风险，即在训练样本集上让误差最小化。这样做的泛化性能不一定好，还有一种做法为结构化风险最小化，典型代表是支持向量机。 logistic回归又称logistic回归分析，是一种广义的线性回归分析模型，常用于数据挖掘，疾病自动诊断，经济预测等领域。例如，探讨引发疾病的危险因素，并根据危险因素预测疾病发生的概率等。以胃癌病情分析为例，选择两组人群，一组是胃癌组，一组是非胃癌组，两组人群必定具有不同的体征与生活方式等。因此因变量就为是否胃癌，值为“是”或“否”，自变量就可以包括很多了，如年龄、性别、饮食习惯、幽门螺杆菌感染等。自变量既可以是连续的，也可以是分类的。然后通过logistic回归分析，可以得到自变量的权重，从而可以大致了解到底哪些因素是胃癌的危险因素。同时根据该权值可以根据危险因素预测一个人患癌症的可能性。是一种用于解决二分类（0 or 1）问题的机器学习方法，用于估计某种事物的可能性。 线性分类 P6高斯判别分析 &amp; P7最大似然函数 高斯判别分析的作用也是用于分类。对于两类样本，其服从伯努利分布，而对每个类中的样本，假定都服从高斯分布，根据训练样本，估计出先验概率以及高斯分布的均值和协方差矩阵（注意这里两类内部高斯分布的协方差矩阵相同），即可通过贝叶斯公式求出一个新样本分别属于两类的概率，进而可实现对该样本的分类。GDA详细推导如P6，那么高斯判别分析的核心工作就是估计未知量ϕ,μ0,μ1,Σ。如何来估计这些参数？又该最大似然估计上场了。其对数似然函数如P6所示，推导如P7。 线性分类 线性分类 P8最大似然函数延申 &amp; P9朴素贝叶斯 上面的推导似乎很复杂，但其结果却是非常简洁。通过上述公式，所有的参数都已经估计出来，需要判断一个新样本x时，可分别使用贝叶斯求出p(y=0|x)和p(y=1|x)，取概率更大的那个类。实际计算时，我们只需要比大小，那么贝叶斯公式中分母项可以不计算，由于2个高斯函数协方差矩阵相同，则高斯分布前面那相同部分也可以忽略。实际上，GDA算法也是一个线性分类器。 贝叶斯学派的思想可以概括为先验概率+数据=后验概率。也就是说我们在实际问题中需要得到的后验概率，可以通过先验概率和数据一起综合得到。数据大家好理解，被频率学派攻击的是先验概率，一般来说先验概率就是我们对于数据所在领域的历史经验，但是这个经验常常难以量化或者模型化，于是贝叶斯学派大胆的假设先验分布的模型，比如正态分布，beta分布等。这个假设一般没有特定的依据，因此一直被频率学派认为很荒谬。虽然难以从严密的数学逻辑里推出贝叶斯学派的逻辑，但是在很多实际应用中，贝叶斯理论很好用，比如垃圾邮件分类，文本分类。 决策的目标是最小化分类错误率，贝叶斯最优分类器要对每个样本x，选择能使后验概率P(c|x)最大的类别c标记。在现实任务中后验概率通常难以直接获得。从这个角度来说，机器学习所要实现的是基于有限的训练样本集尽可能准确地估计出后验概率 P(c|x)。大体来说，主要有两种策略：给定x，可通过直接建模P(c|x)来预测c，这样得到的是“判别式模型”，例如，决策树、BP神经网络、支持向量机等等；也可先对联合概率分布P(x,c)建模，然后在由此获得P(c|x)，这样得到的是“生成式模型”。 贝叶斯估计中类先验概率P(c)表达了样本空间中各类样本所占的比例，根据大数定律，当训练集包含充足的独立同分布样本时，P(c)可通过各类样本出现的频率来进行估计。因为对于类条件概率P(x|c)来说，由于它涉及关于x所有属性的联合概率，直接根据样本出现的频率来估计将会遇到严重的困难。假如样本的d个属性都是二值的，则样本空间将有2的d次方种可能取值，在现实中，这个种类数往往大于训练样本，也就是说，很多样本取值在训练集中根本没有出现，直接使用频率来估计P(x|c)显然不可行，因为“未被观测到”与“出现概率为零”通常是不同的。这可以通过极大似然估计来解决。 基于贝叶斯公式来估计后验概率P(c|x)的主要困难在于：类条件概率P(x|c)是所有属性上的联合概率，难以从有限的训练样本直接估计而得。因此朴素贝叶斯分类器采用了“属性条件独立性假设”：对已知类别，假设所有属性相互独立。也就是说，假设每个属性独立的对分类结果发生影响。 线性分类","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yinqm.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数学理论","slug":"数学理论","permalink":"http://yinqm.com/tags/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/"}]},{"title":"MachineLearning01","slug":"MachineLearning01","date":"2020-03-21T12:24:33.000Z","updated":"2020-03-21T16:40:12.550Z","comments":true,"path":"2020/03/21/MachineLearning01/","link":"","permalink":"http://yinqm.com/2020/03/21/MachineLearning01/","excerpt":"","text":"Frequentist VS Bayesian&emsp;&emsp;在机器学习领域分为两个流派，分别是贝叶斯派和频率派。两种学派所基于的理论背景不同，应用场景也不尽相同。在频率派和贝叶斯派两种理论派别中，似然函数p(D|w)是问题的中心所在，但是对于其被运用的方式方面有着本质的区别。 Frequentist&emsp;&emsp;在频率派中，W被认为是一个固定的数值，其数值的计算是通过对于训练集的学习和估计。这个思想即神经网络中常用的：建立模型，选择损失函数，优化目标函数，将损失降到可以度量范围内的最小值，从而得到对w参数的估计。而在贝叶斯派看来，只有通过观察w的概率分布，才能表示参数的不确定度，即对于w的数值是不确定的。在频率派中一个被广泛使用的用来估计的工具是：最大化似然函数。 Bayesian&emsp;&emsp;贝叶斯派中的一个优势在于对于先验知识的包含是逐步上升的。比如，对一枚质地均匀的硬币进行三次投掷，结果都是反面，则在贝叶斯派的最大化似然函数看来，反面的概率是1. 而对于贝叶斯派来说，由于具有先验知识（质地均匀，先验概率为1/2），其运算结果将不会像频率派一样极端。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yinqm.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"AI科普","slug":"AI科普","permalink":"http://yinqm.com/tags/AI%E7%A7%91%E6%99%AE/"}]},{"title":"MachineLearning02","slug":"MachineLearning02","date":"2020-03-20T09:42:52.000Z","updated":"2020-03-21T16:39:37.073Z","comments":true,"path":"2020/03/20/MachineLearning02/","link":"","permalink":"http://yinqm.com/2020/03/20/MachineLearning02/","excerpt":"","text":"机器学习中常用的数学基础 P1高斯分布（正态分布） 自然界产生的数据分布一般是正态分布（如年龄、身高、体重等），故当对数据不清楚其潜在的结构、即对数据潜在分布模式不明确时，近似采用正态分布。 在机器学习中，目标通常是使得数据线性可分，甚至意味着将数据投影到更高维空间，找到一个可拟合的超平面（如SVM核，神经网络层，softmax等）。原因是“线性分界通常有助于减少方差variance而且是最简单，自然和可理解的”，同时减少数学、计算的复杂性。同时，当我们聚焦线性可分时，通常可以很好减少异常点、影响点和杠杆点的作用。因为超平面是对影响点和杠点（异常点）非常敏感。举个例子，在二维空间中，我们有一个预测器predictor(X)，和目标值（y)，假设X和y是很好的正相关。在这个情形下，假设X是正态分布，y也是正态分布，那么你可以拟合到一条很直的线，相比边界点（异常点，杠杆点），很多点都集中在线的中间，所以这个预测回归线在预测未知数据时，降低方差的影响。 数学基础 P2有偏估计&amp;无偏估计 本质来讲，无偏/无偏估计是指估算统计量的公式，无偏估计就是可以预见，多次采样计算的统计量是在真实值左右两边。类似于正态分布的钟型图形。比如对于均值μ估计。一定有的比μ大，有的比μ小。那么对于有偏估计，就是多次采样，估算的统计量将会在真实值的一侧（都是大于或者都是小于真实值）无偏估计并不一定比有偏估计更加”有效”，因为所谓估算有效是指更加靠近真实值。 数学基础 P3二次型 二次型：n个变量的二次多项式称为二次型，即在一个多项式中，未知数的个数为任意多个，但每一项的次数都为2的多项式。线性代数的重要内容之一，它起源于几何学中二次曲线方程和二次曲面方程化为标准形问题的研究。二次型理论与域的特征有关。PCA跟特征值和特征向量有关，应该跟二次型有关。 数学基础 P4二次型 &amp;&amp; P5： PCA主成分分析用到实对称阵的相似对角化。PCA的目的是降噪和去冗余，是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。 数学基础 P6协方差（Covariance） 在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。 协方差表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。用于机器学习中衡量多个特征之间的关系。 数学基础 P7Jensen不等式（Jensen’s inequality） 在概率论、机器学习、测度论、统计物理等领域都有相关应用。在机器学习领域，用Jensen不等式用来证明KL散度大于等于0,EM算法推导最后也用到了Jensen不等式。 数学基础","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yinqm.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数学理论","slug":"数学理论","permalink":"http://yinqm.com/tags/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/"}]},{"title":"2020第一篇随笔","slug":"2020第一篇随笔","date":"2020-03-15T18:20:09.000Z","updated":"2020-03-21T16:40:55.705Z","comments":true,"path":"2020/03/16/2020第一篇随笔/","link":"","permalink":"http://yinqm.com/2020/03/16/2020%E7%AC%AC%E4%B8%80%E7%AF%87%E9%9A%8F%E7%AC%94/","excerpt":"","text":"&lt;font size=5,face=”微软雅黑”&gt;&emsp;&emsp;兴致所至，做一个自己的网站，起名破站，敲代码水平有限，做得不咋样，但总算可以正常营业了，斯是陋室，惟吾德馨嘛。&emsp;&emsp;“好记性不如烂笔头”，想把自己在学习中遇到的困惑，bug，以及自己最后的解决办法分享出来，互相学习借鉴，如果大家愿意来看，且能够解其惑，自然是相当棒的！其次也可以加深自身印象，在以后的日子里遇到同样的问题，能够更加迅速的解决。&emsp;&emsp;这个博客网站呢，既是为了方便学习用的，也是记录生活。黎明将至，长话短说，总之纪念一下我的小破站做好了，Hello New World！&emsp;&emsp;虽然这个博客网站是因学习而开，但是却也因此打开了新世界的大门，并不愿关上。&emsp;&emsp;愿，脚踏实地，未来可期，&emsp;&emsp;望，法不阿贵，山河无恙。&emsp;&emsp;（Markdown+LaTeX组合写博文确实不错）","categories":[],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://yinqm.com/tags/%E6%9D%82%E8%AE%B0/"},{"name":"心情","slug":"心情","permalink":"http://yinqm.com/tags/%E5%BF%83%E6%83%85/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-14T11:23:15.786Z","updated":"2020-03-14T11:23:15.786Z","comments":true,"path":"2020/03/14/hello-world/","link":"","permalink":"http://yinqm.com/2020/03/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}