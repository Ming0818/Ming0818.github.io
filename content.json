{"meta":{"title":"yinqm_Blog","subtitle":"书不成字，纸短情长","description":"小破站还没设计好，先将就着，哈哈哈哈","author":"Eric Yin","url":"http://yinqm.com","root":"/"},"pages":[{"title":"","date":"2020-03-21T05:54:48.989Z","updated":"2020-03-21T05:54:48.989Z","comments":false,"path":"categories/index.html","permalink":"http://yinqm.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-21T05:54:31.623Z","updated":"2020-03-21T05:54:31.623Z","comments":false,"path":"tags/index.html","permalink":"http://yinqm.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA——Object类和常用API","slug":"JAVA——Object类和常用API","date":"2020-03-23T15:54:12.000Z","updated":"2020-03-23T16:02:40.144Z","comments":true,"path":"2020/03/23/JAVA——Object类和常用API/","link":"","permalink":"http://yinqm.com/2020/03/23/JAVA%E2%80%94%E2%80%94Object%E7%B1%BB%E5%92%8C%E5%B8%B8%E7%94%A8API/","excerpt":"","text":"day01【Object类、常用API】主要内容 Object类 Date类 DateFormat类 Calendar类 System类 StringBuilder类 包装类 第一章 Object类1.1 概述java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 1.2 toString方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 1.3 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。 tips：Object类当中的hashCode等其他方法，今后学习。 1.4 Objects类在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 我们可以查看一下源码，学习一下： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; 第二章 日期时间类2.1 Date类概述java.util.Date类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 2.2 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); &#125; &#125; 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = \"2018年12月11日\"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 2.3 练习请使用日期时间相关的API，计算出一个人已经出生了多少天。 思路： 1.获取当前时间对应的毫秒值 2.获取自己出生日期对应的毫秒值 3.两个时间相减（当前时间– 出生日期） 代码实现： 123456789101112131415161718192021public static void function() throws Exception &#123; System.out.println(\"请输入出生日期 格式 YYYY-MM-dd\"); // 获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); // 将字符串日期,转成Date对象 // 创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); // 调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); // 获取今天的日期对象 Date todayDate = new Date(); // 将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long secone = todaySecond-birthdaySecond; if (secone &lt; 0)&#123; System.out.println(\"还没出生呢\"); &#125; else &#123; System.out.println(secone/1000/60/60/24); &#125;&#125; 2.4 Calendar类概念日历我们都见过 java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 123456789101112131415import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); &#125; &#125; 123456789import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日 &#125;&#125; add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 123456789101112import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; &#125;&#125; getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 第三章 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 3.1 currentTimeMillis方法实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 12345678import java.util.Date;public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; 练习验证for循环打印数字1-9999所需要使用的时间（毫秒） 12345678910public class SystemTest1 &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; long end = System.currentTimeMillis(); System.out.println(\"共耗时毫秒：\" + (end - start)); &#125;&#125; 3.2 arraycopy方法 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 练习将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] 12345678910111213import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; 第四章 StringBuilder类4.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = \"Hello\"; s += \"World\"; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWord 。 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 4.2 StringBuilder概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容(默认16字符空间，超过自动扩充)。 StringBuilder的原理 4.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"itcast\"); System.out.println(sb2); // itcast &#125;&#125; 4.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 12345678910111213141516171819202122public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append(\"hello\"); //对比一下 System.out.println(\"builder:\"+builder); System.out.println(\"builder2:\"+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\"+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 第五章 包装类5.1 概述Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5.2 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—-&gt;包装对象 12Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 1int num = i.intValue(); 5.3自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 5.3 基本类型与字符串之间的转换基本类型转换为String 基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： 1基本类型直接与””相连接即可；如：34+&quot;&quot; String转换成对应的基本类型 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt(\"100\"); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yinqm.com/tags/JAVA/"}]},{"title":"MachineLearning04","slug":"MachineLearning03","date":"2020-03-22T03:11:37.000Z","updated":"2020-03-22T03:43:01.387Z","comments":true,"path":"2020/03/22/MachineLearning03/","link":"","permalink":"http://yinqm.com/2020/03/22/MachineLearning03/","excerpt":"","text":"线性回归P1最小二乘法 &amp; P2概率视角 最小二乘法其实又叫最小平方法，是一种数据拟合的优化技术。实质上是利用最小误差的平方寻求数据的最佳匹配函数，利用最小二乘法可以便捷的求得未知的数据，起到预测的作用，并且是的这些预测的数据与实际数据之间的误差平方和达到最小。一般应用在曲线拟合的目的上。 拟合示意图python代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#%%import matplotlib import matplotlib.pyplot as pltimport numpy as npfrom sklearn import datasets, linear_modelimport pandas as pd # Load CSV and columnsdf = pd.read_csv(\"Housing.csv\") Y = df['price']X = df['lotsize'] X=X.values.reshape(len(X),1)Y=Y.values.reshape(len(Y),1) # Split the data into training/testing setsX_train = X[:-250]X_test = X[-250:] # Split the targets into training/testing setsY_train = Y[:-250]Y_test = Y[-250:] # Create linear regression objectregr = linear_model.LinearRegression() # Train the model using the training setsregr.fit(X_train, Y_train) # Plot outputsplt.scatter(X_test, Y_test, color='black')plt.title('Test Data')plt.xlabel('Size')plt.ylabel('Price')plt.xticks(())plt.yticks(()) # Plot outputsplt.plot(X_test, regr.predict(X_test), color='red',linewidth=3) plt.show()#%%# 画出训练集的拟合曲线，第一种方法predict# Plot outputsplt.scatter(X_train, Y_train, color='black')plt.title('Train Data')plt.xlabel('Size')plt.ylabel('Price')plt.xticks(())plt.yticks(()) # Plot outputsplt.plot(X_train, regr.predict(X_train), color='red',linewidth=3) plt.show() #%%# 画出训练集的拟合曲线，第二种方法coef_*x+intercept_ # Plot outputsplt.scatter(X_train, Y_train, color='black')plt.title('Test Data')plt.xlabel('Size')plt.ylabel('Price')plt.xticks(())plt.yticks(()) # Plot outputsplt.plot(X_train, regr.coef_*X_train+regr.intercept_, color='red',linewidth=3) plt.show() #%%# 查看coef_*x+intercept_的值和regr.predict()的值是否相等，相减为0regr.coef_*X_train+regr.intercept_ - regr.predict(X_train) P3正则化 &amp; 正则化几何解释 正则化看起来有些抽象，其直译”规则化”，本质其实很简单，就是给模型加一些规则限制，约束要优化参数，目的是防止过拟合。其中最常见的规则限制就是添加先验约束，其中L1相当于添加Laplace先验，L相当于添加Gaussian先验。 L1正则是在原始的loss函数上加上一个L1正则化项，这个L1正则项实际就是在loss函数上添加一个结构化风险项，因此正则化其实和“带约束的目标函数”是等价的。而L1正则项就是一个1范数，本质相当于添加一个Laplace先验知识。同理，L2正则化项是一个2范数，本质却相当于添加一个Gaussian先验知识。 过拟合的时候，拟合函数的系数往往非常大，为什么？如P4所示，过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。 一般来说，监督学习可以看做最小化P3的损失函数，第一项L衡量我们的模型（分类或者回归）对第i个样本的预测值f(xi;w)和真实的标签yi之前的误差。因为我们的模型是要拟合我们的训练样本的嘛，所以我们要求这一项最小，也就是要求我们的模型尽量的拟合我们的训练数据。但正如上面说言，我们不仅要保证训练误差最小，我们更希望我们的模型测试误差小，所以我们需要加上第二项，也就是对参数w的规则化函数Ω(w)去约束我们的模型尽量的简单。其中这个规则化函数就是我们常见的L0,L1,L2范数。 正则化的目的：防止过拟合！ 正则化的本质：约束（限制）要优化的参数。 贝叶斯决策理论是主观贝叶斯派归纳理论的重要组成部分。 贝叶斯决策就是在不完全情报下，对部分未知的状态用主观概率估计，然后用贝叶斯公式对发生概率进行修正，最后再利用期望值和修正概率做出最优决策。贝叶斯决策理论方法是统计模型决策中的一个基本方法，其基本思想是： 已知类条件概率密度参数表达式和先验概率 利用贝叶斯公式转换成后验概率 根据后验概率大小进行决策分类 从贝叶斯角度理解正则化从我们平时最为熟悉的最小二乘回归、Ridge回归和LASSO回归入手。从概率论的角度：Least Square的解析解可以用Gaussian分布以及最大似然估计求得Ridge回归可以用Gaussian分布和最大后验估计解释LASSO回归可以用Laplace分布和最大后验估计解释给定观察数据,贝叶斯方法通过最大化后验概率估计参数w。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yinqm.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数学理论","slug":"数学理论","permalink":"http://yinqm.com/tags/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/"}]},{"title":"MachineLearning03","slug":"MachineLearning04","date":"2020-03-21T15:28:25.000Z","updated":"2020-03-21T16:40:32.728Z","comments":true,"path":"2020/03/21/MachineLearning04/","link":"","permalink":"http://yinqm.com/2020/03/21/MachineLearning04/","excerpt":"","text":"线性分类P1线性分类概述 &amp; P2感知机 分类是机器学习中的一个核心问题，在监督学习中，当输出变量Y取有限个离散值时，预测问题便成为分类问题。从数据中学习一个分类模型或分类决策函数，称为分类器。分类器对新的输入进行输出的预测，称为分类，可能的输出称为类，分类的类别为多个时，称为多类分类问题，主要研究的都为二分类问题。许多机器学习方法都是可以用来解分类问题，比如：感知机、朴素贝叶斯、支持向量机、决策树、逻辑回归、AdaBoost、神经网络等等。感知机是神经网络和支持向量机的基础，所以把感知机弄清楚对于其它算法的理解还是挺有必要的。 感知机是一种广泛使用的线性分类器。就是说数据必须是线性可分的(虽然实际中很难达到要求，但是可以通过一些方法将数据集变为线性可分)，属于判别模型(Discriminative Model)。感知器可谓是最简单的人工神经网络，只有一个神经元。感知器是对生物神经元的简单数学模拟，有与生物神经元相对应的部件，如权重（突触）、偏置（阈值）及激活函数（细胞体），输出为+1或-1。感知器是一种简单的两类线性分类模型 线性分类 P3线性判别分析 线性判别分析(linear discriminant analysis，LDA)是对费舍尔的线性鉴别方法的归纳，这种方法使用统计学，模式识别和机器学习方法，试图找到两类物体或事件的特征的一个线性组合，以能够特征化或区分它们。所得的组合可用来作为一个线性分类器，或者，更常见的是，为后续的分类做降维处理。 假设我们对一张100*100像素的图片做人脸识别，每个像素是一个特征，那么会有10000个特征，而对应的类别标签y仅仅是0/1值，1代表是人脸。这么多特征不仅训练复杂，而且不必要特征对结果会带来不可预知的影响，但我们想得到降维后的一些最佳特征（与y关系最密切的）。 主要思想是将一个高维空间中的数据投影到一个较低维的空间中，且投影后要保证各个类别的类内方差小而类间均值差别大，这意味着同一类的高维数据投影到低维空间后相同类别的聚在一起，而不同类别之间相距较远。 线性分类 P4目标函数分析 &amp; P5逻辑回归 线性判别分析（LDA）是一种有监督的数据降维算法，它的目标是最大化类间差异，最小化类内差异。数据经过投影之后，在低维空间里，同类样本聚集在一起，不同类的样本相距尽可能远。类内差异用每个类的方差来衡量，类间差异用各个类的类中心之间的距离来衡量，二者的比值为我们要优化的目标。由此构造出如P4中的损失函数，求解这一问题最后归结为求解矩阵的特征值问题。前面介绍的感知器算法的目标函数，欧氏距离损失，代表的都是经验风险，即在训练样本集上让误差最小化。这样做的泛化性能不一定好，还有一种做法为结构化风险最小化，典型代表是支持向量机。 logistic回归又称logistic回归分析，是一种广义的线性回归分析模型，常用于数据挖掘，疾病自动诊断，经济预测等领域。例如，探讨引发疾病的危险因素，并根据危险因素预测疾病发生的概率等。以胃癌病情分析为例，选择两组人群，一组是胃癌组，一组是非胃癌组，两组人群必定具有不同的体征与生活方式等。因此因变量就为是否胃癌，值为“是”或“否”，自变量就可以包括很多了，如年龄、性别、饮食习惯、幽门螺杆菌感染等。自变量既可以是连续的，也可以是分类的。然后通过logistic回归分析，可以得到自变量的权重，从而可以大致了解到底哪些因素是胃癌的危险因素。同时根据该权值可以根据危险因素预测一个人患癌症的可能性。是一种用于解决二分类（0 or 1）问题的机器学习方法，用于估计某种事物的可能性。 线性分类 P6高斯判别分析 &amp; P7最大似然函数 高斯判别分析的作用也是用于分类。对于两类样本，其服从伯努利分布，而对每个类中的样本，假定都服从高斯分布，根据训练样本，估计出先验概率以及高斯分布的均值和协方差矩阵（注意这里两类内部高斯分布的协方差矩阵相同），即可通过贝叶斯公式求出一个新样本分别属于两类的概率，进而可实现对该样本的分类。GDA详细推导如P6，那么高斯判别分析的核心工作就是估计未知量ϕ,μ0,μ1,Σ。如何来估计这些参数？又该最大似然估计上场了。其对数似然函数如P6所示，推导如P7。 线性分类 线性分类 P8最大似然函数延申 &amp; P9朴素贝叶斯 上面的推导似乎很复杂，但其结果却是非常简洁。通过上述公式，所有的参数都已经估计出来，需要判断一个新样本x时，可分别使用贝叶斯求出p(y=0|x)和p(y=1|x)，取概率更大的那个类。实际计算时，我们只需要比大小，那么贝叶斯公式中分母项可以不计算，由于2个高斯函数协方差矩阵相同，则高斯分布前面那相同部分也可以忽略。实际上，GDA算法也是一个线性分类器。 贝叶斯学派的思想可以概括为先验概率+数据=后验概率。也就是说我们在实际问题中需要得到的后验概率，可以通过先验概率和数据一起综合得到。数据大家好理解，被频率学派攻击的是先验概率，一般来说先验概率就是我们对于数据所在领域的历史经验，但是这个经验常常难以量化或者模型化，于是贝叶斯学派大胆的假设先验分布的模型，比如正态分布，beta分布等。这个假设一般没有特定的依据，因此一直被频率学派认为很荒谬。虽然难以从严密的数学逻辑里推出贝叶斯学派的逻辑，但是在很多实际应用中，贝叶斯理论很好用，比如垃圾邮件分类，文本分类。 决策的目标是最小化分类错误率，贝叶斯最优分类器要对每个样本x，选择能使后验概率P(c|x)最大的类别c标记。在现实任务中后验概率通常难以直接获得。从这个角度来说，机器学习所要实现的是基于有限的训练样本集尽可能准确地估计出后验概率 P(c|x)。大体来说，主要有两种策略：给定x，可通过直接建模P(c|x)来预测c，这样得到的是“判别式模型”，例如，决策树、BP神经网络、支持向量机等等；也可先对联合概率分布P(x,c)建模，然后在由此获得P(c|x)，这样得到的是“生成式模型”。 贝叶斯估计中类先验概率P(c)表达了样本空间中各类样本所占的比例，根据大数定律，当训练集包含充足的独立同分布样本时，P(c)可通过各类样本出现的频率来进行估计。因为对于类条件概率P(x|c)来说，由于它涉及关于x所有属性的联合概率，直接根据样本出现的频率来估计将会遇到严重的困难。假如样本的d个属性都是二值的，则样本空间将有2的d次方种可能取值，在现实中，这个种类数往往大于训练样本，也就是说，很多样本取值在训练集中根本没有出现，直接使用频率来估计P(x|c)显然不可行，因为“未被观测到”与“出现概率为零”通常是不同的。这可以通过极大似然估计来解决。 基于贝叶斯公式来估计后验概率P(c|x)的主要困难在于：类条件概率P(x|c)是所有属性上的联合概率，难以从有限的训练样本直接估计而得。因此朴素贝叶斯分类器采用了“属性条件独立性假设”：对已知类别，假设所有属性相互独立。也就是说，假设每个属性独立的对分类结果发生影响。 线性分类","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yinqm.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数学理论","slug":"数学理论","permalink":"http://yinqm.com/tags/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/"}]},{"title":"MachineLearning01","slug":"MachineLearning01","date":"2020-03-21T12:24:33.000Z","updated":"2020-03-21T16:40:12.550Z","comments":true,"path":"2020/03/21/MachineLearning01/","link":"","permalink":"http://yinqm.com/2020/03/21/MachineLearning01/","excerpt":"","text":"Frequentist VS Bayesian&emsp;&emsp;在机器学习领域分为两个流派，分别是贝叶斯派和频率派。两种学派所基于的理论背景不同，应用场景也不尽相同。在频率派和贝叶斯派两种理论派别中，似然函数p(D|w)是问题的中心所在，但是对于其被运用的方式方面有着本质的区别。 Frequentist&emsp;&emsp;在频率派中，W被认为是一个固定的数值，其数值的计算是通过对于训练集的学习和估计。这个思想即神经网络中常用的：建立模型，选择损失函数，优化目标函数，将损失降到可以度量范围内的最小值，从而得到对w参数的估计。而在贝叶斯派看来，只有通过观察w的概率分布，才能表示参数的不确定度，即对于w的数值是不确定的。在频率派中一个被广泛使用的用来估计的工具是：最大化似然函数。 Bayesian&emsp;&emsp;贝叶斯派中的一个优势在于对于先验知识的包含是逐步上升的。比如，对一枚质地均匀的硬币进行三次投掷，结果都是反面，则在贝叶斯派的最大化似然函数看来，反面的概率是1. 而对于贝叶斯派来说，由于具有先验知识（质地均匀，先验概率为1/2），其运算结果将不会像频率派一样极端。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yinqm.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"AI科普","slug":"AI科普","permalink":"http://yinqm.com/tags/AI%E7%A7%91%E6%99%AE/"}]},{"title":"MachineLearning02","slug":"MachineLearning02","date":"2020-03-20T09:42:52.000Z","updated":"2020-03-21T16:39:37.073Z","comments":true,"path":"2020/03/20/MachineLearning02/","link":"","permalink":"http://yinqm.com/2020/03/20/MachineLearning02/","excerpt":"","text":"机器学习中常用的数学基础 P1高斯分布（正态分布） 自然界产生的数据分布一般是正态分布（如年龄、身高、体重等），故当对数据不清楚其潜在的结构、即对数据潜在分布模式不明确时，近似采用正态分布。 在机器学习中，目标通常是使得数据线性可分，甚至意味着将数据投影到更高维空间，找到一个可拟合的超平面（如SVM核，神经网络层，softmax等）。原因是“线性分界通常有助于减少方差variance而且是最简单，自然和可理解的”，同时减少数学、计算的复杂性。同时，当我们聚焦线性可分时，通常可以很好减少异常点、影响点和杠杆点的作用。因为超平面是对影响点和杠点（异常点）非常敏感。举个例子，在二维空间中，我们有一个预测器predictor(X)，和目标值（y)，假设X和y是很好的正相关。在这个情形下，假设X是正态分布，y也是正态分布，那么你可以拟合到一条很直的线，相比边界点（异常点，杠杆点），很多点都集中在线的中间，所以这个预测回归线在预测未知数据时，降低方差的影响。 数学基础 P2有偏估计&amp;无偏估计 本质来讲，无偏/无偏估计是指估算统计量的公式，无偏估计就是可以预见，多次采样计算的统计量是在真实值左右两边。类似于正态分布的钟型图形。比如对于均值μ估计。一定有的比μ大，有的比μ小。那么对于有偏估计，就是多次采样，估算的统计量将会在真实值的一侧（都是大于或者都是小于真实值）无偏估计并不一定比有偏估计更加”有效”，因为所谓估算有效是指更加靠近真实值。 数学基础 P3二次型 二次型：n个变量的二次多项式称为二次型，即在一个多项式中，未知数的个数为任意多个，但每一项的次数都为2的多项式。线性代数的重要内容之一，它起源于几何学中二次曲线方程和二次曲面方程化为标准形问题的研究。二次型理论与域的特征有关。PCA跟特征值和特征向量有关，应该跟二次型有关。 数学基础 P4二次型 &amp;&amp; P5： PCA主成分分析用到实对称阵的相似对角化。PCA的目的是降噪和去冗余，是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。 数学基础 P6协方差（Covariance） 在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。 协方差表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。用于机器学习中衡量多个特征之间的关系。 数学基础 P7Jensen不等式（Jensen’s inequality） 在概率论、机器学习、测度论、统计物理等领域都有相关应用。在机器学习领域，用Jensen不等式用来证明KL散度大于等于0,EM算法推导最后也用到了Jensen不等式。 数学基础","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yinqm.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数学理论","slug":"数学理论","permalink":"http://yinqm.com/tags/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/"}]},{"title":"2020第一篇随笔","slug":"2020第一篇随笔","date":"2020-03-15T18:20:09.000Z","updated":"2020-03-21T16:40:55.705Z","comments":true,"path":"2020/03/16/2020第一篇随笔/","link":"","permalink":"http://yinqm.com/2020/03/16/2020%E7%AC%AC%E4%B8%80%E7%AF%87%E9%9A%8F%E7%AC%94/","excerpt":"","text":"&lt;font size=5,face=”微软雅黑”&gt;&emsp;&emsp;兴致所至，做一个自己的网站，起名破站，敲代码水平有限，做得不咋样，但总算可以正常营业了，斯是陋室，惟吾德馨嘛。&emsp;&emsp;“好记性不如烂笔头”，想把自己在学习中遇到的困惑，bug，以及自己最后的解决办法分享出来，互相学习借鉴，如果大家愿意来看，且能够解其惑，自然是相当棒的！其次也可以加深自身印象，在以后的日子里遇到同样的问题，能够更加迅速的解决。&emsp;&emsp;这个博客网站呢，既是为了方便学习用的，也是记录生活。黎明将至，长话短说，总之纪念一下我的小破站做好了，Hello New World！&emsp;&emsp;虽然这个博客网站是因学习而开，但是却也因此打开了新世界的大门，并不愿关上。&emsp;&emsp;愿，脚踏实地，未来可期，&emsp;&emsp;望，法不阿贵，山河无恙。&emsp;&emsp;（Markdown+LaTeX组合写博文确实不错）","categories":[],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://yinqm.com/tags/%E6%9D%82%E8%AE%B0/"},{"name":"心情","slug":"心情","permalink":"http://yinqm.com/tags/%E5%BF%83%E6%83%85/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-14T11:23:15.786Z","updated":"2020-03-14T11:23:15.786Z","comments":true,"path":"2020/03/14/hello-world/","link":"","permalink":"http://yinqm.com/2020/03/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}